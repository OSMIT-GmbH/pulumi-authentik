// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package authentik

import (
	"context"
	"reflect"

	"errors"
	"github.com/OSMIT-GmbH/pulumi-authentik/sdk/v2024/go/authentik/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/OSMIT-GmbH/pulumi-authentik/sdk/v2024/go/authentik"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create expression policys
//			_, err := authentik.NewPolicyExpression(ctx, "name", &authentik.PolicyExpressionArgs{
//				Name:       pulumi.String("expression"),
//				Expression: pulumi.String("return True"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type PolicyExpression struct {
	pulumi.CustomResourceState

	// Defaults to `false`.
	ExecutionLogging pulumi.BoolPtrOutput `pulumi:"executionLogging"`
	Expression       pulumi.StringOutput  `pulumi:"expression"`
	Name             pulumi.StringOutput  `pulumi:"name"`
}

// NewPolicyExpression registers a new resource with the given unique name, arguments, and options.
func NewPolicyExpression(ctx *pulumi.Context,
	name string, args *PolicyExpressionArgs, opts ...pulumi.ResourceOption) (*PolicyExpression, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Expression == nil {
		return nil, errors.New("invalid value for required argument 'Expression'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PolicyExpression
	err := ctx.RegisterResource("authentik:index/policyExpression:PolicyExpression", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicyExpression gets an existing PolicyExpression resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicyExpression(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyExpressionState, opts ...pulumi.ResourceOption) (*PolicyExpression, error) {
	var resource PolicyExpression
	err := ctx.ReadResource("authentik:index/policyExpression:PolicyExpression", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PolicyExpression resources.
type policyExpressionState struct {
	// Defaults to `false`.
	ExecutionLogging *bool   `pulumi:"executionLogging"`
	Expression       *string `pulumi:"expression"`
	Name             *string `pulumi:"name"`
}

type PolicyExpressionState struct {
	// Defaults to `false`.
	ExecutionLogging pulumi.BoolPtrInput
	Expression       pulumi.StringPtrInput
	Name             pulumi.StringPtrInput
}

func (PolicyExpressionState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyExpressionState)(nil)).Elem()
}

type policyExpressionArgs struct {
	// Defaults to `false`.
	ExecutionLogging *bool   `pulumi:"executionLogging"`
	Expression       string  `pulumi:"expression"`
	Name             *string `pulumi:"name"`
}

// The set of arguments for constructing a PolicyExpression resource.
type PolicyExpressionArgs struct {
	// Defaults to `false`.
	ExecutionLogging pulumi.BoolPtrInput
	Expression       pulumi.StringInput
	Name             pulumi.StringPtrInput
}

func (PolicyExpressionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyExpressionArgs)(nil)).Elem()
}

type PolicyExpressionInput interface {
	pulumi.Input

	ToPolicyExpressionOutput() PolicyExpressionOutput
	ToPolicyExpressionOutputWithContext(ctx context.Context) PolicyExpressionOutput
}

func (*PolicyExpression) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyExpression)(nil)).Elem()
}

func (i *PolicyExpression) ToPolicyExpressionOutput() PolicyExpressionOutput {
	return i.ToPolicyExpressionOutputWithContext(context.Background())
}

func (i *PolicyExpression) ToPolicyExpressionOutputWithContext(ctx context.Context) PolicyExpressionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyExpressionOutput)
}

// PolicyExpressionArrayInput is an input type that accepts PolicyExpressionArray and PolicyExpressionArrayOutput values.
// You can construct a concrete instance of `PolicyExpressionArrayInput` via:
//
//	PolicyExpressionArray{ PolicyExpressionArgs{...} }
type PolicyExpressionArrayInput interface {
	pulumi.Input

	ToPolicyExpressionArrayOutput() PolicyExpressionArrayOutput
	ToPolicyExpressionArrayOutputWithContext(context.Context) PolicyExpressionArrayOutput
}

type PolicyExpressionArray []PolicyExpressionInput

func (PolicyExpressionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyExpression)(nil)).Elem()
}

func (i PolicyExpressionArray) ToPolicyExpressionArrayOutput() PolicyExpressionArrayOutput {
	return i.ToPolicyExpressionArrayOutputWithContext(context.Background())
}

func (i PolicyExpressionArray) ToPolicyExpressionArrayOutputWithContext(ctx context.Context) PolicyExpressionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyExpressionArrayOutput)
}

// PolicyExpressionMapInput is an input type that accepts PolicyExpressionMap and PolicyExpressionMapOutput values.
// You can construct a concrete instance of `PolicyExpressionMapInput` via:
//
//	PolicyExpressionMap{ "key": PolicyExpressionArgs{...} }
type PolicyExpressionMapInput interface {
	pulumi.Input

	ToPolicyExpressionMapOutput() PolicyExpressionMapOutput
	ToPolicyExpressionMapOutputWithContext(context.Context) PolicyExpressionMapOutput
}

type PolicyExpressionMap map[string]PolicyExpressionInput

func (PolicyExpressionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyExpression)(nil)).Elem()
}

func (i PolicyExpressionMap) ToPolicyExpressionMapOutput() PolicyExpressionMapOutput {
	return i.ToPolicyExpressionMapOutputWithContext(context.Background())
}

func (i PolicyExpressionMap) ToPolicyExpressionMapOutputWithContext(ctx context.Context) PolicyExpressionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyExpressionMapOutput)
}

type PolicyExpressionOutput struct{ *pulumi.OutputState }

func (PolicyExpressionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyExpression)(nil)).Elem()
}

func (o PolicyExpressionOutput) ToPolicyExpressionOutput() PolicyExpressionOutput {
	return o
}

func (o PolicyExpressionOutput) ToPolicyExpressionOutputWithContext(ctx context.Context) PolicyExpressionOutput {
	return o
}

// Defaults to `false`.
func (o PolicyExpressionOutput) ExecutionLogging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PolicyExpression) pulumi.BoolPtrOutput { return v.ExecutionLogging }).(pulumi.BoolPtrOutput)
}

func (o PolicyExpressionOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyExpression) pulumi.StringOutput { return v.Expression }).(pulumi.StringOutput)
}

func (o PolicyExpressionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyExpression) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type PolicyExpressionArrayOutput struct{ *pulumi.OutputState }

func (PolicyExpressionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyExpression)(nil)).Elem()
}

func (o PolicyExpressionArrayOutput) ToPolicyExpressionArrayOutput() PolicyExpressionArrayOutput {
	return o
}

func (o PolicyExpressionArrayOutput) ToPolicyExpressionArrayOutputWithContext(ctx context.Context) PolicyExpressionArrayOutput {
	return o
}

func (o PolicyExpressionArrayOutput) Index(i pulumi.IntInput) PolicyExpressionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PolicyExpression {
		return vs[0].([]*PolicyExpression)[vs[1].(int)]
	}).(PolicyExpressionOutput)
}

type PolicyExpressionMapOutput struct{ *pulumi.OutputState }

func (PolicyExpressionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyExpression)(nil)).Elem()
}

func (o PolicyExpressionMapOutput) ToPolicyExpressionMapOutput() PolicyExpressionMapOutput {
	return o
}

func (o PolicyExpressionMapOutput) ToPolicyExpressionMapOutputWithContext(ctx context.Context) PolicyExpressionMapOutput {
	return o
}

func (o PolicyExpressionMapOutput) MapIndex(k pulumi.StringInput) PolicyExpressionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PolicyExpression {
		return vs[0].(map[string]*PolicyExpression)[vs[1].(string)]
	}).(PolicyExpressionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyExpressionInput)(nil)).Elem(), &PolicyExpression{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyExpressionArrayInput)(nil)).Elem(), PolicyExpressionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyExpressionMapInput)(nil)).Elem(), PolicyExpressionMap{})
	pulumi.RegisterOutputType(PolicyExpressionOutput{})
	pulumi.RegisterOutputType(PolicyExpressionArrayOutput{})
	pulumi.RegisterOutputType(PolicyExpressionMapOutput{})
}

// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package authentik

import (
	"context"
	"reflect"

	"errors"
	"github.com/OSMIT-GmbH/pulumi-authentik/sdk/v2024/go/authentik/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manage Scope Provider Property mappings
//
// > This resource is deprecated. Migrate to `PropertyMappingProviderScope`.
type ScopeMapping struct {
	pulumi.CustomResourceState

	Description pulumi.StringPtrOutput `pulumi:"description"`
	Expression  pulumi.StringOutput    `pulumi:"expression"`
	Name        pulumi.StringOutput    `pulumi:"name"`
	ScopeName   pulumi.StringOutput    `pulumi:"scopeName"`
}

// NewScopeMapping registers a new resource with the given unique name, arguments, and options.
func NewScopeMapping(ctx *pulumi.Context,
	name string, args *ScopeMappingArgs, opts ...pulumi.ResourceOption) (*ScopeMapping, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Expression == nil {
		return nil, errors.New("invalid value for required argument 'Expression'")
	}
	if args.ScopeName == nil {
		return nil, errors.New("invalid value for required argument 'ScopeName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ScopeMapping
	err := ctx.RegisterResource("authentik:index/scopeMapping:ScopeMapping", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetScopeMapping gets an existing ScopeMapping resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetScopeMapping(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ScopeMappingState, opts ...pulumi.ResourceOption) (*ScopeMapping, error) {
	var resource ScopeMapping
	err := ctx.ReadResource("authentik:index/scopeMapping:ScopeMapping", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ScopeMapping resources.
type scopeMappingState struct {
	Description *string `pulumi:"description"`
	Expression  *string `pulumi:"expression"`
	Name        *string `pulumi:"name"`
	ScopeName   *string `pulumi:"scopeName"`
}

type ScopeMappingState struct {
	Description pulumi.StringPtrInput
	Expression  pulumi.StringPtrInput
	Name        pulumi.StringPtrInput
	ScopeName   pulumi.StringPtrInput
}

func (ScopeMappingState) ElementType() reflect.Type {
	return reflect.TypeOf((*scopeMappingState)(nil)).Elem()
}

type scopeMappingArgs struct {
	Description *string `pulumi:"description"`
	Expression  string  `pulumi:"expression"`
	Name        *string `pulumi:"name"`
	ScopeName   string  `pulumi:"scopeName"`
}

// The set of arguments for constructing a ScopeMapping resource.
type ScopeMappingArgs struct {
	Description pulumi.StringPtrInput
	Expression  pulumi.StringInput
	Name        pulumi.StringPtrInput
	ScopeName   pulumi.StringInput
}

func (ScopeMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*scopeMappingArgs)(nil)).Elem()
}

type ScopeMappingInput interface {
	pulumi.Input

	ToScopeMappingOutput() ScopeMappingOutput
	ToScopeMappingOutputWithContext(ctx context.Context) ScopeMappingOutput
}

func (*ScopeMapping) ElementType() reflect.Type {
	return reflect.TypeOf((**ScopeMapping)(nil)).Elem()
}

func (i *ScopeMapping) ToScopeMappingOutput() ScopeMappingOutput {
	return i.ToScopeMappingOutputWithContext(context.Background())
}

func (i *ScopeMapping) ToScopeMappingOutputWithContext(ctx context.Context) ScopeMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScopeMappingOutput)
}

// ScopeMappingArrayInput is an input type that accepts ScopeMappingArray and ScopeMappingArrayOutput values.
// You can construct a concrete instance of `ScopeMappingArrayInput` via:
//
//	ScopeMappingArray{ ScopeMappingArgs{...} }
type ScopeMappingArrayInput interface {
	pulumi.Input

	ToScopeMappingArrayOutput() ScopeMappingArrayOutput
	ToScopeMappingArrayOutputWithContext(context.Context) ScopeMappingArrayOutput
}

type ScopeMappingArray []ScopeMappingInput

func (ScopeMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScopeMapping)(nil)).Elem()
}

func (i ScopeMappingArray) ToScopeMappingArrayOutput() ScopeMappingArrayOutput {
	return i.ToScopeMappingArrayOutputWithContext(context.Background())
}

func (i ScopeMappingArray) ToScopeMappingArrayOutputWithContext(ctx context.Context) ScopeMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScopeMappingArrayOutput)
}

// ScopeMappingMapInput is an input type that accepts ScopeMappingMap and ScopeMappingMapOutput values.
// You can construct a concrete instance of `ScopeMappingMapInput` via:
//
//	ScopeMappingMap{ "key": ScopeMappingArgs{...} }
type ScopeMappingMapInput interface {
	pulumi.Input

	ToScopeMappingMapOutput() ScopeMappingMapOutput
	ToScopeMappingMapOutputWithContext(context.Context) ScopeMappingMapOutput
}

type ScopeMappingMap map[string]ScopeMappingInput

func (ScopeMappingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScopeMapping)(nil)).Elem()
}

func (i ScopeMappingMap) ToScopeMappingMapOutput() ScopeMappingMapOutput {
	return i.ToScopeMappingMapOutputWithContext(context.Background())
}

func (i ScopeMappingMap) ToScopeMappingMapOutputWithContext(ctx context.Context) ScopeMappingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScopeMappingMapOutput)
}

type ScopeMappingOutput struct{ *pulumi.OutputState }

func (ScopeMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScopeMapping)(nil)).Elem()
}

func (o ScopeMappingOutput) ToScopeMappingOutput() ScopeMappingOutput {
	return o
}

func (o ScopeMappingOutput) ToScopeMappingOutputWithContext(ctx context.Context) ScopeMappingOutput {
	return o
}

func (o ScopeMappingOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScopeMapping) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o ScopeMappingOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v *ScopeMapping) pulumi.StringOutput { return v.Expression }).(pulumi.StringOutput)
}

func (o ScopeMappingOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ScopeMapping) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ScopeMappingOutput) ScopeName() pulumi.StringOutput {
	return o.ApplyT(func(v *ScopeMapping) pulumi.StringOutput { return v.ScopeName }).(pulumi.StringOutput)
}

type ScopeMappingArrayOutput struct{ *pulumi.OutputState }

func (ScopeMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScopeMapping)(nil)).Elem()
}

func (o ScopeMappingArrayOutput) ToScopeMappingArrayOutput() ScopeMappingArrayOutput {
	return o
}

func (o ScopeMappingArrayOutput) ToScopeMappingArrayOutputWithContext(ctx context.Context) ScopeMappingArrayOutput {
	return o
}

func (o ScopeMappingArrayOutput) Index(i pulumi.IntInput) ScopeMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ScopeMapping {
		return vs[0].([]*ScopeMapping)[vs[1].(int)]
	}).(ScopeMappingOutput)
}

type ScopeMappingMapOutput struct{ *pulumi.OutputState }

func (ScopeMappingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScopeMapping)(nil)).Elem()
}

func (o ScopeMappingMapOutput) ToScopeMappingMapOutput() ScopeMappingMapOutput {
	return o
}

func (o ScopeMappingMapOutput) ToScopeMappingMapOutputWithContext(ctx context.Context) ScopeMappingMapOutput {
	return o
}

func (o ScopeMappingMapOutput) MapIndex(k pulumi.StringInput) ScopeMappingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ScopeMapping {
		return vs[0].(map[string]*ScopeMapping)[vs[1].(string)]
	}).(ScopeMappingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ScopeMappingInput)(nil)).Elem(), &ScopeMapping{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScopeMappingArrayInput)(nil)).Elem(), ScopeMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScopeMappingMapInput)(nil)).Elem(), ScopeMappingMap{})
	pulumi.RegisterOutputType(ScopeMappingOutput{})
	pulumi.RegisterOutputType(ScopeMappingArrayOutput{})
	pulumi.RegisterOutputType(ScopeMappingMapOutput{})
}
